package pack;

import java.util.HashMap;

public class VM extends LexVM
{
	protected static HashMap<Integer, Integer> jumpMap = new HashMap<Integer, Integer>();
	//protected static Instruction [] instructionArray = new Instruction[1000];
	protected static String [] instructionArray = new String[1000];
	protected static int arrayLocation = 0; //for printing the array


	public static void main(String[] args) 
	{
		Stream.setStream(args[0], args[1]);
		String val = getToken();
		String colon = "";
		while(val != null)
		{
			//System.out.println("Token: " + val);
			//System.out.println("inside while\n");
			//case if and signed or unsigned, one can parse a jump target
			if(LexVM.state.equals(State.SignedInt) || LexVM.state.equals(State.UnsignedInt) )
			{
				//System.out.println("inside sign or unsign");
				//switch(LexVM.state) // based on the state, switch
			//	{
				//case SignedInt:
					//System.out.println("case sign\n");
					int target = Integer.parseInt(val);
					if (target < 0)
					{
						Stream.displayln("Syntax Error: Jump target cannot be negative, parser extracted " + target + "\n");
						Stream.close();
						return;
					}
					else
					{
						colon = getToken();
						if(colon == null || !LexVM.state.equals(State.Colon) )
						{
							Stream.displayln("Syntax Error: Jump expects colon, parser extracted " + colon + "\n");
							Stream.close();
							return;
						}
//						else if (!LexVM.state.equals(State.Colon))
//						{
//							Stream.displayln("Syntax Error: Jump expects colon, parser extracted " + colon + "\n");
//							Stream.close();
//							return;
//						}
						else
						{
							if(jumpMap.containsKey(target))
							{
								Stream.displayln("Syntax Error: The jump target " + val + " appears more than once\n");
								Stream.close();
								return;
							}
							jumpMap.put(target, arrayLocation);
							//System.out.println("Mapped unsigned to " + targetSigned + ", " + arrayLocation);
						}
					}
					//break;
				//case UnsignedInt:
					//System.out.println("inside unsign\n");
				//	int targetUnsigned = Integer.parseInt(val);
					//colon = getToken();
					//System.out.println("Val in unsign, suposed colon " + colon);
//					if(colon == null || !LexVM.state.equals(State.Colon) )
//					{
//						Stream.displayln("Syntax Error: Jump expects colon, parser extracted " + colon + "\n");
//						Stream.close();
//						return;
//					}
					//					else if (!LexVM.state.equals(State.Colon))
					//					{
					//						Stream.displayln("Syntax Error: Jump expects colon, parser extracted " + colon + "\n");
					//						Stream.close();
					//						return;
					//					}
//					else
//					{
//						if(jumpMap.containsKey(targetUnsigned))
//						{
//							Stream.displayln("Syntax Error: The jump target " + Integer.parseInt(val) + " appears more than once\n");
//							Stream.close();
//							return;
//						}
//						jumpMap.put(targetUnsigned, arrayLocation);
//						System.out.println("Mapped unsigned to " + targetUnsigned + ", " + arrayLocation);
//					}
//					break;
//				default:
//					Stream.displayln("\nProblem parsing jump target");

			}
			else
			{
				System.out.println("Printed :" + val + " at " + arrayLocation);
				instructionArray[arrayLocation++] = val;
				switch(val) 
				{
				default: break;
				}
			}
		
			//				switch(val)
			//				{
			//		syso
			//				}
			val = getToken();
		}
		System.out.println("Printing Map");
		for (HashMap.Entry<Integer,Integer> entry : jumpMap.entrySet())  
			System.out.println("Key = " + entry.getKey() + 
					", Value = " + entry.getValue()); 

		System.out.println("Printing the array");
		printInstructionArray();
		Stream.close();
	}




	public static void printInstructionArray()
	{ 

		//		for (Instruction instruct : instructionArray)
		//			Stream.displayln(place++ + ": " + instruct.print());
		for (int i = 0; i < arrayLocation; i++)
			Stream.displayln(i + ": " + instructionArray[i]);
	}

}
